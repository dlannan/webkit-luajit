// -----------------------------------------------------------------------------------------------------------------------------------------

var CameraType =  Object.freeze({
    "Unknown": 0,
    "Ortho": 1,
    "Perspective": 2
});

// -----------------------------------------------------------------------------------------------------------------------------------------

var toneMappingOptions =  Object.freeze({
	"None": THREE.NoToneMapping,
	"Linear": THREE.LinearToneMapping,
	"Reinhard": THREE.ReinhardToneMapping,
	"Uncharted2": THREE.Uncharted2ToneMapping,
	"Cineon": THREE.CineonToneMapping,
	"ACESFilmic": THREE.ACESFilmicToneMapping
});

// -----------------------------------------------------------------------------------------------------------------------------------------

THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {
    var dx = ( this.right - this.left ) / ( 2 * this.zoom );
    var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
    var cx = ( this.right + this.left ) / 2;
    var cy = ( this.top + this.bottom ) / 2;
    this.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );
};					


function createPerspOrthoCameras() {

    allcameras = {
        ortho: new SEERCamera( CameraType.Ortho ),
        persp: new SEERCamera( CameraType.Perspective ),
    };        
    {# console.log("Creating cameras: ", allcameras); #}
}

// -----------------------------------------------------------------------------------------------------------------------------------------
// Camera object - this is a set of data defining a sensor or rgb camera setup
//		Get camera info from THREE Camera if needed.

var SEERCamera = function( camType, pos, fov, near, far ) {

	this.name 		= "Camera_" + UID();
	this.sensor		= "RGB"; // TODO: Need sensor enum

    // Sensible defaults
	this.near		= 0.3;
	this.far		= 2500;
	this.fov		= 60.0;
	this.pos 		= new THREE.Vector3( 20, 10, 20 );
	this.effects 	= [];

	this.width 		= window.innerWidth;
	this.height 	= window.innerHeight;

    // Override defaults if needed
    if(pos) this.pos = pos;
    if(fov) this.fov = fov;
    if(near) this.near = near;
    if(far) this.far = far;

	this.dir 		= new THREE.Vector3();
	this.worldUp 	= new THREE.Vector3(0,1,0);
	this.worldPlane = new THREE.Plane(this.worldUp);
	this.rtScale 	= 1.0;

    var orthoDiv 	= 8;
    this.camera     = undefined;

    if((camType === CameraType.Perspective) || (camType == undefined)) {
        this.camera = new THREE.PerspectiveCamera( this.fov, window.innerWidth / window.innerHeight, this.near, this.far );
    }
    if(camType === CameraType.Ortho) {
        this.camera = new THREE.OrthographicCamera( window.innerWidth / - orthoDiv, window.innerWidth / orthoDiv, window.innerHeight / orthoDiv, window.innerHeight / - orthoDiv, this.near, this.far );
    }

    this.camera.position.set( this.pos.x, this.pos.y, this.pos.z );

    var target = new THREE.Object3D();
    target.position.set( 0,0,0 );

    this.camera.target = target;
    this.camera.lookAt( target.position );

	this.objectlink 	= undefined;

	// -----------------------------------------------------------------------------------------------------------------------------------------
    // The depth camera will be same on Ortho and Persp (and most others too)
	this.depthResolution = 128;
	this.depthSize = 8.0;
	this.depthDeep = 5.0;
	this.depthScale = this.depthResolution / this.depthSize;
	this.depthXY = this.depthSize / this.depthResolution;

    this.depthCamera = new THREE.OrthographicCamera( this.depthSize / - 2, this.depthSize / 2, this.depthSize / 2, this.depthSize / - 2, 0, this.depthDeep )
    this.depthCamera.target = this.camera.target;
    this.depthBuffer = new Float32Array( this.depthResolution * this.depthResolution * 4 );
	
	// This is set to true after the first buffer render
	this.depthIsReady = false;
	
	// -----------------------------------------------------------------------------------------------------------------------------------------
	// Special effects - need to be able to switch these without reload (should be able to)
	this.thermalEffect 	= undefined;
	this.nvPass = undefined;

	this.depthEffect 	= undefined;
	this.depthTexture 	= undefined;
	this.renderDepthTexture 	= undefined;
	this.depthMat 		= undefined;
	this.orthoCamera 	= undefined;
	this.perspCamera 	= undefined;

	this.mainWindow 	= undefined;
	this.renderer 		= undefined;

	// This camera renderer..
	this.makeRender	= function( container, ratio, logdepth, winRender ) {

		if(!logdepth) logdepth = false;
		
		// The renderer for this camera...
		this.renderer = new THREE.WebGLRenderer({
			canvas: container,
			antialias: true,
			physicallyCorrectLights: true,
			preserveDrawingBuffer: true,
			logarithmicDepthBuffer: logdepth 
		});

		// Renderer setup properties
		this.renderer.setClearColor(0xffffff);
		this.renderer.shadowMap.enabled = true;
		this.renderer.shadowMap.type = THREE.PCFSoftShadowMap

		// Parameters for tonemapping...
		var params = {
			opacity: 1.0,
			roughness: 1.0,
			bumpScale: 1.0,
			exposure: 1.5,
			whitePoint: 1.0,
			toneMapping: toneMappingOptions.ACESFilmic,
			renderMode: "Renderer"
		};

		this.renderer.toneMapping = params.toneMapping;
		this.renderer.toneMappingExposure = params.exposure;
		this.renderer.toneMappingWhitePoint = params.whitePoint;
		this.renderer.gammaOutput = true;

		this.renderer.setPixelRatio( ratio );

		//renderer.gammaFactor = 2.2;
		//renderer.gammaInput = true;
		//renderer.gammaOutput = true;

		var parameters = { 
			minFilter: THREE.LinearFilter, 
			magFilter: THREE.LinearFilter, 
			format: THREE.RGBFormat,
			stencilBuffer: false,
			generateMipmaps: false
		};

		if( winRender == undefined ) {
			winRender = {
				"width": container.offsetWidth,
				"height": container.offsetHeight
			};
		}
		this.w = this.width; //winRender.width;
		this.h = this.height; //winRender.height;		

		this.renderTarget = new THREE.WebGLRenderTarget( this.w * this.rtScale, this.h * this.rtScale, parameters );
		this.renderTarget.depthBuffer = true;
		this.renderTarget.depthTexture = new THREE.DepthTexture();
		this.renderTarget.depthTexture.type = THREE.UnsignedShortType;
		this.renderTarget.autoClearColor = false;
		this.renderTarget.autoClearDepth = false;
		this.renderDepthTexture = this.renderTarget.depthTexture 

		// This keeps a copy of the rendered sky (last frame)
		this.skyTexture = null;

		this.addComposer();

		// Create depth texture for height map for entities
		parameters.format = THREE.RGBAFormat;
		parameters.minFilter = THREE.LinearFilter; 
		parameters.magFilter = THREE.LinearFilter; 
		this.depthTextureRT = new THREE.WebGLRenderTarget( this.depthResolution, this.depthResolution, parameters ); 
		//this.depthTextureRT.depthBuffer = true;
		this.depthTextureRT.texture.type = THREE.FloatType;
		//this.depthTextureRT.depthTexture = new THREE.DepthTexture(this.depthResolution, this.depthResolution);
		//this.depthTextureRT.depthTexture.type = THREE.UnsignedShortType;
		//this.depthTexture = this.depthTextureRT.depthTexture;
	};

	this.addComposer = function() {

		this.composer = new THREE.EffectComposer(this.renderer, this.renderTarget);
		this.baseRenderPass = new THREE.RenderPass(scene, this.camera);
		this.composer.addPass(this.baseRenderPass);

		this.baseRenderPass.renderToScreen = true;
		this.baseRenderPass.clear = true;
	};

    this.active = function() {
		
		seerCamera = this;
		camera = this.camera;
		renderer = this.renderer;
		depthCamera = this.depthCamera;
		depthTexture = this.depthTexture;
		renderTarget = this.renderTarget;
		composer = this.composer;
	};

	// Examples: LIDAR128, THERMAL, SOBEL, RGB
    this.addEffect = function(effectName) {
		
		this.baseRenderPass.renderToScreen = false;
		if(effectName == "RGB") return;
		this.baseRenderPass.clear = true;
		this.renderEffectPass = addEffect(this, effectName );
		this.renderEffectPass.clear = false;
	};

	// AA needs to be done before camera abberations are made. AA can be various types as needed.
	//renderEffectPass = applyAntiAliasing( composer );
	// Examples: GLITCH and NOISE
    this.addCameraEffect = function(cameraEffectName, clearBase) {
	
		if(!clearBase) clearBase = true;
		this.baseRenderPass.clear = clearBase;
		this.renderEffectPass = addCameraEffect(this, cameraEffectName );
		this.renderEffectPass.clear = false;
	};

	this.disableBasePass = function() {

		if(this.baseRenderPass) {
		this.baseRenderPass.clear = true;
		this.baseRenderPass.renderToScreen = false;
		}
	};

	// Use this when finished adding composer effects
	this.endEffect = function() {

		if(this.renderEffectPass) {
		this.renderEffectPass.clear = true;
		this.renderEffectPass.renderToScreen = true;
		}
	};

    this.addFXAA = function() {
		
        this.fxaaPass = new THREE.ShaderPass(THREE.FXAAShader);
		
		var pixelRatio = this.renderer.getPixelRatio();
		this.fxaaPass.material.uniforms[ 'resolution' ].value.x = 1 / ( this.w * pixelRatio );
		this.fxaaPass.material.uniforms[ 'resolution' ].value.y = 1 / ( this.h * pixelRatio );
		this.composer.addPass(this.fxaaPass);
    };

	this.addSSAO = function( ) {
			
		this.effectSSAO = new THREE.SSAOPass( scene, this.camera, this.w, this.h );
		{# effectSSAO.renderToScreen = true; #}
		this.composer.addPass( this.effectSSAO );	
		this.effectSSAO.ssaoMaterial.uniforms['cameraFar'].value = 100.0;
		this.effectSSAO.setSize( this.w, this.h );
	}	

    this.addBloom = function() {
        
        this.bloom = new THREE.UnrealBloomPass(new THREE.Vector2( this.w, this.h ), 1.0, 0.1, 0.85);
		this.bloom.threshold = 1.2;
		this.bloom.strength = 1.0;
		this.bloom.radius = 0.1;
		this.composer.addPass(this.bloom);
        {# this.renderPass = this.bloom; #}
		this.bloom.setSize( this.w * 1.5, this.h * 1.5 );
    };

    this.addDepth = function() {

		console.log("Adding depth render.");

		// So I can view the depth texture - add to camera as child.
		this.depthMat = new THREE.MeshStandardMaterial( { 
			map: this.depthTextureRT.texture, 
			flatShading: true, 
			color: new THREE.Color(0xffffff) }
		);   

		this.depthImg = new THREE.Mesh(new THREE.PlaneGeometry(this.depthSize, this.depthSize), this.depthMat);
		this.depthImg.rotation.order = 'ZYX';
		this.depthImg.rotation.set(-Math.PI/2, 0.0, 0.0);
		this.depthImg.visible = true;
		this.depthImg.position.set(-this.depthSize/2, 1, -this.depthSize/2);
		scene.add(this.depthImg);
    };
};


var Gcamera, Grenderer, Gcomposer, GrenderTarget;

function saveGlobals() {
	
	Gcamera = camera;
	Grenderer = renderer;
	//GdepthCamera = depthCamera;
	//GdepthTexture = depthTexture;
	GrenderTarget = renderTarget;
	Gcomposer = composer;
};

function restoreGlobals() {
	
	camera = Gcamera;
	renderer = Grenderer;
//	depthCamera = GdepthCamera;
//	depthTexture = GdepthTexture;
	renderTarget = GrenderTarget;
	composer = Gcomposer;
};

function moveWithObject( seerCamera ) {
	var obj = SceneGraph.findNodeByUid( seerCamera.objectlink ); 
	if(obj != undefined) {
		seerCamera.camera.position.set( obj.position.x, obj.position.y, obj.position.z );
		seerCamera.camera.rotation.set( obj.rotation.x, obj.rotation.y, obj.rotation.z );
	}
}

function mapCanvasToCamera( id, channel, effect, cameraeffect ) {

	var sensorid = 'sensor' + id;
	allcameras[sensorid] = new SEERCamera( CameraType.Perspective );

	var container = document.getElementById( 'container' + id );
	allcameras[sensorid].makeRender( container, window.devicePixelRatio );

	if(effect) allcameras[sensorid].addEffect(effect);
	if(cameraeffect) allcameras[sensorid].addCameraEffect(cameraeffect);
	if(effect || cameraeffect) {
		allcameras[sensorid].endEffect();
		allcameras[sensorid].disableBasePass();
	}

	allcameras[sensorid].name = "SENSOR" + id;
	mappedChannels[channel] = allcameras[sensorid];

	// Add sensor menus and borders
	var newmenu = $("#sensor-menu").clone();
	newmenu.attr("id", "sensor-menu" + id);
	$(container).parent().append( newmenu );
	initSensorMenu( $("#sensor-menu" + id + " > nav" ) );
	newmenu.show();
}

function LinkCameraToObject( seerCameraid, objectlink ) {
	// If camera is tied to an object
	var seerCamera = mappedChannels[seerCameraid];
	if(objectlink != undefined) {
		seerCamera.objectlink = objectlink;
		seerCamera.cameraUpdate = moveWithObject;
	}
}


function heightLookupOcean( Scamera ) {

    // Used for heightmap lookup and buoyancy (can be used for terrain)
    // NOTE: To be extracted into entity management and vehicles.
    if(Scamera.depthCamera && ocean) {
        // Render onto our off-screen texture
        var obj = SceneGraph.findNodeByUid(selectEditorObj);
        var isModel = false;
        if(obj && obj.userData.parentType === "models") isModel = true;
        
        if(isModel) {
            if(!('origPosition' in obj)) { obj.origPosition = obj.position.y; }
            Scamera.depthCamera.position.set(obj.position.x, obj.position.y + 5, obj.position.z);
        	Scamera.depthImg.position.set(obj.position.x, obj.position.y + 1, obj.position.z);

		    //Scamera.depthCamera.lookAt( obj.position.x, obj.position.y, obj.position.z );			
			var xyz = SceneGraph.getEntityEuler( selectEditorObj );
            Scamera.depthCamera.rotation.set( -Math.PI * 0.5, 0.0, 0.0 );

            ocean.material.uniforms.entity.value.copy(obj.position);
            ocean.material.uniforms.entity.value.y = obj.rotation.y;
            ocean.material.uniforms.entityCheck.value = 3.0;
            renderer.setRenderTarget(Scamera.depthTextureRT);
            renderer.render(sceneDepth, Scamera.depthCamera);
            ocean.material.uniforms.entityCheck.value = 0.0;
            //this.depthMat.map = Scamera.depthTexture.texture;

            // Now use the depth texture on entity control
            renderer.readRenderTargetPixels( Scamera.depthTextureRT, 0, 0, Scamera.depthResolution, 
						Scamera.depthResolution, Scamera.depthBuffer );
			Scamera.depthIsReady = 	true;						
        }
    }
}

function heightLookup( Scamera, obj ) {

    // Used for heightmap lookup and buoyancy (can be used for terrain)
    // NOTE: To be extracted into entity management and vehicles.
    if(Scamera.depthCamera) {

        // Render onto our off-screen texture
		if(!('origPosition' in obj)) { obj.origPosition = obj.position.y; }

		Scamera.depthCamera.position.set(obj.position.x, obj.position.y + 2, obj.position.z);
		if(Scamera.depthImg) Scamera.depthImg.position.set(obj.position.x, obj.position.y + 0.2, obj.position.z);
		Scamera.depthCamera.rotation.set( -Math.PI * 0.5, 0.0, 0.0 );

		renderer.setRenderTarget(Scamera.depthTextureRT);
		renderer.render(sceneDepth, Scamera.depthCamera);
		renderer.setRenderTarget(Scamera.renderTarget);
		//this.depthMat.map = Scamera.depthTexture.texture;

		// Now use the depth texture on entity control
		renderer.readRenderTargetPixels( Scamera.depthTextureRT, 0, 0, Scamera.depthResolution, 
						Scamera.depthResolution, Scamera.depthBuffer );
		Scamera.depthIsReady = 	true;
    }
}

function getSelectedRotation(Scamera) {

	var p1 = Scamera.depthBuffer[(32 * Scamera.depthResolution + 32) * 4] * 0.0039215 - 0.5;
	var p2 = Scamera.depthBuffer[(32 * Scamera.depthResolution + 96) * 4] * 0.0039215 - 0.5;
	var p3 = Scamera.depthBuffer[(96 * Scamera.depthResolution + 64) * 4] * 0.0039215 - 0.5;
	//console.log([p1, p2, p3]);

	// Sample three positions for rot X, Z and pos Y
	var obj = SceneGraph.findNodeByUid(selectEditorObj);
	obj.position.y = lerp(obj.position.y, obj.origPosition + (p1 + p2 + p3) / 3.0, 0.1);
	
	var xrot = Math.atan2((p1 + p2) * 0.5 - p3, 4.0);
	var zrot = Math.atan2((p1 - p2), 4.0);

	var fwd = SceneGraph.getEntityForward( obj.id );
	SceneGraph.updateEntityForward(obj.id, xrot,  )
	
	obj.rotation.set(lerp(obj.rotation.x, xrot, .2), 
					obj.rotation.y, 
					lerp(obj.rotation.z, zrot, .2));

}