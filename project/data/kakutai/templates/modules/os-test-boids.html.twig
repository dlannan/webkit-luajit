// ----------------------------------------------------------------------------
//
//
// OpenSteer -- Steering Behaviors for Autonomous Characters
//
// Copyright (c) 2002-2003, Sony Computer Entertainment America
// Original author: Craig Reynolds <craig_reynolds@playstation.sony.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
//
// ----------------------------------------------------------------------------
//
//
// OpenSteer Boids
// 
// 09-26-02 cwr: created 
//
//
// ----------------------------------------------------------------------------


var Boid = function(pd) {

    // allocate one and share amoung instances just to save memory usage
    // (change to per-instance allocation to be more MP-safe)
    this.neighbors = [];

    // allocate a token for this boid in the proximity database
    this.proximityToken = undefined;

    // type for a group of Pedestrians
    //typedef std::vector<Pedestrian*> groupType;
    this.mover = new SimpleVehicle();

    // destructor
    this.deleteBoid = function() {
        // delete this boid's token in the proximity database
        if(this.proximityToken) delete this.proximityToken;
    }

    // reset state
    this.reset = function() {
        // reset the vehicle
        this.mover.reset();
        this.mover.setRadius(8.0);

        // steering force is clipped to this magnitude
        this.mover.setMaxForce(50.0);

        // velocity is clipped to this magnitude
        this.mover.setMaxSpeed(45.0);

        // initial slow speed
        this.mover.setSpeed(this.mover.maxSpeed() * (frandom01() + 0.6));

        // randomize initial orientation
        this.mover.regenerateOrthonormalBasisUF(RandomUnitVector());

        // randomize initial position
        this.mover.setPosition(RandomVectorInUnitRadiusSphere().mult( 200.0) );

        // notify proximity database that our position has changed
        this.proximityToken.updateForNewPosition (this.mover.position());
    }

    // draw this boid into the scene
    this.draw = function() {
        // drawTrail ();
    }

    // per frame simulation update
    this.update = function(currentTime, elapsedTime) {
        // steer to flock and perhaps to stay within the spherical boundary
        this.mover.applySteeringForce (this.steerToFlock().add( this.handleBoundary()), elapsedTime);

        // notify proximity database that our position has changed
        this.proximityToken.updateForNewPosition (this.mover.position());
    }

    // basic flocking
    this.steerToFlock = function() {
        var separationRadius =  8.0;
        var separationAngle  = -0.707;
        var separationWeight =  12.0;

        var alignmentRadius = 12.5;
        var alignmentAngle  = 0.7;
        var alignmentWeight = 8.0;

        var cohesionRadius = 15.0;
        var cohesionAngle  = -0.15;
        var cohesionWeight = 8.0;

        var maxRadius = maxXXX(separationRadius, maxXXX (alignmentRadius, cohesionRadius));

        // find all flockmates within maxRadius using proximity database
        this.neighbors = this.proximityToken.findNeighbors(this.mover.position(), maxRadius);

        // determine each of the three component behaviors of flocking
        var separation = this.mover.steerForSeparation(separationRadius, separationAngle, this.neighbors);
        var alignment  = this.mover.steerForAlignment(alignmentRadius, alignmentAngle, this.neighbors);
        var cohesion   = this.mover.steerForCohesion(cohesionRadius, cohesionAngle, this.neighbors);

        // apply weights to components (save in variables for annotation)
        var separationW = separation.mult(separationWeight);
        var alignmentW = alignment.mult(alignmentWeight);
        var cohesionW = cohesion.mult(cohesionWeight);

        // annotation
        // const float s = 0.1;
        // annotationLine (position, position + (separationW * s), gRed);
        // annotationLine (position, position + (alignmentW  * s), gOrange);
        // annotationLine (position, position + (cohesionW   * s), gYellow);

        return separationW.add(alignmentW.add(cohesionW));
    }


    // Take action to stay within sphereical boundary.  Returns steering
    // value (which is normally zero) and may take other side-effecting
    // actions such as kinematically changing the Boid's position.
    this.handleBoundary = function() {
        // while inside the sphere do noting
        if (this.mover.position().length() < Boid.worldRadius) return Vec3.zero;

        // once outside, select strategy
        if(Boid.boundaryCondition === 0) {
            // steer back when outside
            var seek = this.mover.xxxsteerForSeek(Vec3.zero);
            var lateral = seek.perpendicularComponent(this.mover.forward ());
            return lateral;
        }
        if(Boid.boundaryCondition === 1) {
            // wrap around (teleport)
            this.mover.setPosition(this.mover.position().sphericalWrapAround(Vec3.zero, Boid.worldRadius));
            return Vec3.zero;
        }
        return Vec3.zero; // should not reach here
    }


    // make boids "bank" as they fly
    this.regenerateLocalSpace = function(newVelocity, elapsedTime) {
        this.mover.regenerateLocalSpaceForBanking (newVelocity, elapsedTime);
    }

    // switch to new proximity database -- just for demo purposes
    this.newPD = function(pd) {
        // delete this boid's token in the old proximity database
        delete this.proximityToken;

        // allocate a token for this boid in the proximity database
        this.proximityToken = pd.allocateToken(this);
    }

    // cycle through various boundary conditions
    this.nextBoundaryCondition = function() {
        var max = 2;
        Boid.boundaryCondition = (Boid.boundaryCondition + 1) % max;
    }

    this.newPD(pd);
    // reset all boid state
    this.reset();
};

Boid.worldRadius  =  150.0;
Boid.worldCenter  = Vec3Set(0.0, 100.0, 0.0)
Boid.boundaryCondition = 0;

// ----------------------------------------------------------------------------

var center = Vec3Set(0.0, 0.0, 0.0);
var div = 10.0;
var divisions = Vec3Set(div, div, div);
var diameter = Boid.worldRadius * 1.1 * 2;
var dimensions = Vec3Set(diameter, diameter, diameter);
console.log(divisions, dimensions);
var GPD = new LQProximityDatabase( center, dimensions, divisions);

var population = 0;
var flock = [];
var drone;

var oldTime;
var currentTime; 
var elapsedTime;

function addBoidToFlock (pd) {
    population++;
    var boid = new Boid(pd);

    boid['node'] = THREE.SkeletonUtils.clone( drone );
    models.add( boid['node'] );

    flock.push(boid);
}

function removeBoidFromFlock () {
    if (population > 0) {
        // save a pointer to the last boid, then remove it from the flock
        var boid = flock[-1];
        flock.pop();
        population--;

        // delete the Boid
        boid.deleteBoid();
    }
}

function handleFunctionKeys (keyNumber) {
    if(keyNumber === 1)  addBoidToFlock();
    if(keyNumber === 2)  removeBoidFromFlock (); 
}

function boidUpdater() {

    oldTime = currentTime;
    currentTime = Date.now() / 1000.0;
    elapsedTime = currentTime - oldTime;
    
    // update each Boid
    for (var i = 0; i < flock.length; i++) {
        flock[i].update(currentTime, elapsedTime);

        var pos = flock[i].mover.position();
        var fwd = flock[i].mover.forward();
        var side = flock[i].mover.side();

        var targetP = new THREE.Vector3( pos.x, pos.y + 220.0, pos.z);
        var targetR = new THREE.Vector3( -fwd.x, -fwd.y, -fwd.z);

        flock[i]["updatetime"] = currentTime;
        flock[i]["tweenpos"] = animateVector4(flock[i].node, targetP, targetR, {
            
            duration: elapsedTime * 1000.0, 
            easing : TWEEN.Easing.Linear.None,
            callback : function(){
                //console.log("Completed");
            }
        });  

    }
    setTimeout( boidUpdater, 20 );
}

$(document).ready(function() {

    console.log("Testing OpenSteer Boids.");
    console.log("LQDB:", GPD);

    scenestatus.watch("loaded", function (id, oldval, newval) {

        console.log("Loaded scene.. starting boids.");
        if(newval == true ) {

            // Get character thats been loaded
            drone = models.children[0];

            // create the specified number of Pedestrians
            population = 0;
            for (var i = 0; i < 20; i++) {
                addBoidToFlock(GPD);    
            }
        
            currentTime = Date.now() / 1000.0;
            boidUpdater();
        }
        return newval;
    });    
});