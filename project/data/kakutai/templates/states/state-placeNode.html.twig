
function checkNodePlacement( ) {

    var ok = (mode.state === EditorMode.NODENEW) || 
                (mode.state === EditorMode.NODEPLACE);
                
    if(!ok) return;

    //console.log("SHIFT: ", shiftPressed);

    // When shift pressed only allow vertical movement
    if(shiftPressed === true) {
        if( mode.object ) {
            if(placeNodeState.mousey === undefined) {
                placeNodeState.mousey = mouse.y;
                placeNodeState.cursposy = mode.object.position.y;
            }
            if(mouseMove === true) {            
                var pos = selectCursor.position;
                pos.y = placeNodeState.cursposy + (mouse.y - placeNodeState.mousey) * mouseMoveYScale;
                selectCursor.position.copy( pos );
                mode.object.position.copy( pos );
            }

            SceneGraph.updateEntityPosition( mode.object.userData.uid, mode.object.position.x, placeNodeState.cursposy, mode.object.position.z );        
            SceneGraph.forceUpdate( mode.object.userData.uid );        
            SceneGraph.forceRender( mode.object.userData.uid );                        
        }
    }
    else {
        var intersections = checkHit();

        if ( intersections.length > 0 ) {

            var intersected = closestHit( mode.object, intersections );
            if(intersected != undefined) {

                //intersected = intersections[ i ].object;
                selectCursor.position.copy( intersected.point );

                var n = intersected.normal;
                var d = camera.position.distanceTo( intersected.point );
                
                selectCursor.scale.set( 2, 2, 2 );
                //selectCursor.lookAt( intersected.point + n );

                if(mode.object) {
                    mode.object.position.copy( intersected.point );
                }
            }
        }
        else {

            var line = new THREE.Line3(camera.position, camera.position + cameraDir * 5000.0);
            var target = new THREE.Vector3();
            var pt = allcameras.persp.worldPlane.intersectLine(line, target);
            var d = pt.distanceTo(camera.position);
            
            selectCursor.position.copy(pt);
            //selectCursor.scale.set( d, d, d );
            //selectCursor.lookAt( pt + worldUp );

            //intersected = null;
        }


        if(mode.object) {
            var pos = mode.object.position;
            SceneGraph.updateEntityPosition( mode.object.userData.uid, pos.x, pos.y, pos.z );        
            SceneGraph.forceUpdate( mode.object.userData.uid );        
            SceneGraph.forceRender( mode.object.userData.uid );                        
        }
    }
}

var placeNodeState = {

    name: "placenode",
    value: 0,              // Set this value to react to external state control
    parent: undefined,      // If this is set, exit ensures the parent state is reactivated
    nodes: undefined,
    lastnode: undefined,
    way: undefined,
    mousey: undefined,

    onenter: function(init) {

        selectCursor.material.color.setHex(0xff0000);
        selectCursor.visible = true;
        hidePopups();
        disableControls();
        if (!placeNodeState.nodes) {
            placeNodeState.nodes = new Array();
        }
        placeNodeState.lastnode = undefined;
        placeNodeState.mousey = undefined;
        console.log("INIT");
    },

    onupdate: function(dt) {
        // Dont do much - its an init state, nothing to see here.
        checkNodePlacement();
    },

    onmouse: function( event ) {

        if(event.type === "mouseup") {

            mode.group = nodes;
            check = (mode.state === EditorMode.NODENEW); 
            if(check) {

                // Check if a spline is already here (intersects) if not, place a new one   
                var intersections = checkHit( nodes.children );
                var closespline = false;
                if ( intersections.length > 0 ) {

                    // check object isnt the one we are dragging around!!
                    var intersected = closestHit( mode.object, intersections );
                    if(intersected != undefined) {
                        if(intersected.object.userData.parentType == ObjectTypes.NODES) {
                            closespline = true;
                        }
                    }
                }

                if(closespline === true) {

                    console.log("CLOSE SPLINE");
                    updateWay(placeNodeState.way, placeNodeState.nodes);

                    clearSelection();
                    selectCursor.visible = false;
                    enableControls();                                         
                    mode.state = EditorMode.NONE;    

                    placeNodeState.nodes = new Array();
                    placeNodeState.way = undefined;      
                    placeNodeState.lastnode = undefined;
                } else {

                    // Capture mesh - this is what will be tested
                    uidNode(mode.object);
                    placeNodeState.lastnode = mode.object.children[0];
                    console.log("NEW NODE");

                    placeNodeState.nodes.push( mode.object.userData.uid );
                    FinishPlacement();

                    if(placeNodeState.nodes.length == 2) {
                        placeNodeState.way = newWay(placeNodeState.nodes);
                    } else if (placeNodeState.nodes.length > 2){
                        updateWay(placeNodeState.way, placeNodeState.nodes);
                    }

                    newNodeSelect();
                }
            } else {

                var tempways = nodewaylu[mode.object.userData.uid];
                for(var key in tempways ) {
                    var way = tempways[key];
                    //console.log(way, tempways, mode.object);
                    updateWay( ways.getObjectById(way,true), waylu[way] );
                }

                FinishPlacement();
                mode.state = EditorMode.NONE;
                console.log("DESELECT");
                placeNodeState.lastnode = undefined;
                placeNodeState.mousey = undefined;
            }
        }
    },

    onexit: function() {
    }
};